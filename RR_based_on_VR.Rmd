---
title: "Virus Infection Dynamics Calculations"
author: "Socheata Hour"
date: "January 04 2025"
output:
  html_document: default
  md_document: default
  pdf_document: default    
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown

 renv::init()
 

## Calculates I~SC~, as well as AUC and other necessary values to achieve I~SC~
   This loads necessary packages and finds N~asymptote~ for both control and infected

```{r}
install.packages("dplyr",repos = "http://cran.us.r-project.org")
install.packages("ggplot2",repos = "http://cran.us.r-project.org")
install.packages("readxl",repos = "http://cran.us.r-project.org")
install.packages("DescTools",repos = "http://cran.us.r-project.org")
```

```{r}
library("dplyr")
library("ggplot2")
library("readxl") 
library("DescTools")

```

## Read in your data to the R environment from excel using Import Dataset function
Data should be in the following format in excel:

hpi=Hours post infection, abs=absorbance at 600nm

| time.hpi | ctrl.abs | virus1.abs | virus2.abs | ctrl.sd | virus1.sd | virus2.sd |
|----------|----------|------------|------------|---------|-----------|-----------|
| 0        | 0.2      | 0.2        | 0.2        | 0.05    | 0.05      | 0.05      |
| 2        | 0.4      | 0.3        | 0.35       | 0.1     | 0.03      | 0.02      |

```{r}
setwd("/Users/socheatahour/Desktop/Relative_resilience_research/code/")
testing = read_xlsx("fusellovirus.xlsx")
```

```{r}
#the following finds asymptotes
time=testing[c("time.hpi")] #change to specify column
con_abs=testing[c("ctrl.abs")] #change to specify column
Nasymcon <- max(con_abs) #picks max value from specified column
con_inf=testing[c("virus1.abs")] #change to specify column
Nasyminf <- max(con_inf) #pick max value from specified column
```

## To calculate PI~max~, I~SC~, PI~AUC~, and V~R~
Using the equations below from "Quantifying relative virulence", https://doi.org/10.1099/jgv.0.001515
$$PI_{max} = (1- N_{asymptote(infected)}/N_{asymptote(control)}) * 100$$
$$I_{SC} = [PI_{AUC} * PI_{max}]^{1/2}$$
$$PI_{AUC} = (1- AUC_{(infected)}/AUC_{(control)}) * 100$$
$$V_{R} = V_{R} + (I_{SC}[i+1] + I_{SC}[i])*(t[i+1]-t[i])/(t_{n}-t_{1})/2$$
```{r}
PIMAX=(1-(Nasyminf/Nasymcon))*100 #calculates PImax
AUCcon=AUC(testing$time.hpi[14:46], testing$ctrl.abs[14:46])#AUC for control, change ratio as needed, ratio should be [1:total number of time points to include] 39:41 gordonia selected   1:57 gordonia full  1:46 fusellovirus full 14:46 fusell mid
AUCinf=AUC(testing$time.hpi[14:46], testing$virus1.abs[14:46])#AUC for infected, change ratio as needed 
PIAUC=(1-(AUCinf/AUCcon))*100 #calculates PIauc
Isc=(PIAUC*PIMAX)^(0.5) #calculates Isc

# To calculate VR, we calculate N.asy.inf, N.asy.ctr, AUC.inf, AUC.ctr, PI.AUC, PI.max and I.sc for each upperbound
time = testing$time.hpi[14:46]
ctr.abs = testing$ctrl.abs[14:46]
inf.abs = testing$virus1.abs[14:46]

Nasyminf.vec = numeric()
Nasyminf.vec[1] = 0
Nasymcon.vec = numeric()
Nasymcon.vec[1] = 0
AUCinf.vec = numeric()
AUCinf.vec[1] = 0
AUCcon.vec = numeric()
AUCcon.vec[1] = 0
PIAUC.vec = numeric()
PIAUC.vec[1] = 0
PIMAX.vec= numeric()
PIMAX.vec[1] = 0 
Isc.vec = numeric()
Isc.vec[1] = 0
oneOverIsc.vec = numeric()

for(i in 1:length(time)){
  time.temp = time[1:i]
  ctr.abs.temp = ctr.abs[1:i]
  inf.abs.temp = inf.abs[1:i]
  Nasyminf.vec[i] = max(inf.abs.temp)
  Nasymcon.vec[i] = max(ctr.abs.temp)
  AUCinf.vec[i] = AUC(time.temp, inf.abs.temp)
  AUCcon.vec[i] = AUC(time.temp, ctr.abs.temp)
  PIAUC.vec[i] = (1-AUCinf.vec[i]/AUCcon.vec[i])*100
  PIMAX.vec[i] = (1-Nasyminf.vec[i]/Nasymcon.vec[i])*100
  Isc.vec[i] = sqrt(abs(PIAUC.vec[i])*abs(PIMAX.vec[i]))
  oneOverIsc.vec[i] = 1/Isc.vec[i]
}

results = data.frame(time,
                     ctr.abs,
                     inf.abs,
                     Nasymcon.vec,
                     Nasyminf.vec,
                     AUCcon.vec,
                     AUCinf.vec,
                     PIAUC.vec,
                     PIMAX.vec,
                     Isc.vec,
                     oneOverIsc.vec)

# Finally we calculate VR 
VR = 0 # initial value
# Note that here t0 is not involved, so t1 = time[2]
for(i in 2:(nrow(results)-1)){
  VR = VR + (Isc.vec[i+1] + Isc.vec[i])*(time[i+1]-time[i])/(time[nrow(results)]-time[1])/2
}
results$VR <- VR
VR
RR <- 1/VR
results$RR <- RR
results
write.csv(results, file = "results.csv", row.names = FALSE)

```